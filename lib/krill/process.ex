defmodule Krill.Process do
  @moduledoc """
  Deals with anything related to Porcelain.Process and Results
  """

  alias Porcelain.Result
  require Logger
  import Krill, only: [empty?: 1]

  @status_ok 0
  @status_error_generic 1

  @doc """
  Runs the comand stored in `state`, and returns the new state containing
  the `stdout` and `stderr`.

  Returns `{:ok, state}`
  """
  @spec run(Command.t, non_neg_integer | :infinity) :: {:ok, Command.t}
  def run(state, timeout \\ :infinity) do
    case state.process do
      nil ->
        #Logger.debug("PID: #{inspect self}")
        opts = [ out: {:send, self}, err: {:send, self}, ]
        %Porcelain.Process{pid: pid} = process = Porcelain.spawn_shell(state.command, opts)
        _state_handled = handle_output(self, pid, state)
        receive do
          {:ok, state} ->
            state = state
          
          after timeout ->
            exit(:timeout)
        end
        state = Map.put(state, :process, process)
        {:ok, state}

      _ ->
        {:ok, state}
    end
  end

  @doc """
  Consumes the output generated by `run/2`, storing the information
  in the `state`.

  Returns `{:ok, state}`
  """
  @spec handle_output(pid, pid, Command.t, pos_integer) :: {:ok, Command.t}
  def handle_output(sender, pid, state, counter \\ 1) do
    receive do
      { ^pid, :data, :out, data } ->
        #Logger.debug(data)
        {data_lines, counter_updated} = get_multiline_data(data, counter)
        {_, state_updated} = get_and_update_in( state.stdout_raw, &({&1, &1 ++ data_lines }) )
        handle_output(sender, pid, state_updated, counter_updated)

      { ^pid, :data, :err, data } ->
        #Logger.debug(data)
        {data_lines, counter_updated} = get_multiline_data(data, counter)
        {_, state_updated} = get_and_update_in( state.stderr_raw, &({&1, &1 ++ data_lines }) )
        handle_output( sender, pid, state_updated, counter_updated)

      { ^pid, :result, result=%Result{status: status} } ->
        state = Map.merge(state, %{status_raw: status, result: result})
        send sender, { :ok, state }
    end
  end

  # Reads multiline `data` and returns a tuple, containing ,
  # in the format of {[{line_no, line}, ...], counter}
  @spec get_multiline_data(String.t, pos_integer) :: {[Krill.std_line], pos_integer}
  defp get_multiline_data(data, counter) do
    String.rstrip(data, ?\n)
      |> String.split("\n")
      |> Enum.map_reduce( counter, fn(line, line_no) -> {{line_no, line}, line_no+1} end )
  end

  @doc """
  Determines the output `status` to be set, based on the state information.
  """
  @spec determine_status(Command.t) :: non_neg_integer
  def determine_status(state) do
    cond do
      empty?(state.stderr) ->
        @status_ok

      # status_raw is @status_ok, but stderr neither empty, nor falsey
      state.status_raw == @status_ok ->
        @status_error_generic
      
      # set same as status_raw
      true ->
        state.status_raw
    end
  end

end